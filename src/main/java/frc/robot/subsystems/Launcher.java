// RobotBuilder Version: 6.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;


import frc.robot.Constants.CanIds;
import frc.robot.RobotContainer;
import frc.robot.commands.*;

import com.revrobotics.spark.SparkMax;
import com.revrobotics.spark.config.SparkBaseConfig.IdleMode;
import com.revrobotics.spark.config.SparkMaxConfig;
import javax.lang.model.util.ElementScanner14;
import com.revrobotics.spark.ClosedLoopSlot;
import com.revrobotics.spark.FeedbackSensor;
import com.revrobotics.spark.SparkBase.ControlType;
import com.revrobotics.spark.SparkBase.PersistMode;
import com.revrobotics.spark.SparkLowLevel.MotorType;
import com.revrobotics.spark.SparkBase.ResetMode;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.units.measure.Distance;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Launcher extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    public LFlywheels flywheels_LH;
    public LFlywheels flywheels_RH;
    public LTurret turret;
    private Pose2d targetPose;
    private LauncherStatus status = LauncherStatus.STOPPED;
    private String combinedStatus = "Initializing";
    private Pose2d currentPose = new Pose2d(1, 4, new Rotation2d(0));
    private double distanceToTarget;
    private double targetAngle;
    private double currentAngle;
    private boolean bActive = true;

    private LinearCalcRef short_shot = new LinearCalcRef(2503, 196, edu.wpi.first.units.Units.Centimeter);
    private LinearCalcRef long_shot = new LinearCalcRef(4407, 379, edu.wpi.first.units.Units.Centimeter);
    private LinearCalc shotCalc = new LinearCalc(short_shot, long_shot);
    private double targetRPM;


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    /**
    *
    */
    public Launcher() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS


        LFlywheels flywheels_LH = new LFlywheels(CanIds.MOTORS.TOWER1_MOTOR_RIGHT.canId, CanIds.MOTORS.TOWER1_MOTOR_LEFT.canId);
        LFlywheels flywheels_RH = new LFlywheels(CanIds.MOTORS.TOWER2_MOTOR_RIGHT.canId, CanIds.MOTORS.TOWER2_MOTOR_LEFT.canId);
        LTurret turret = new LTurret();
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

        //calculate combined status values from each sub component
        combinedStatus = status.toString() + " T "+ turret.getStatus().toString()+ " L " 
        + flywheels_LH.getStatus().toString() + " R " + flywheels_RH.getStatus().toString();
        //update current robot pose from drivetrain odometry
         currentPose = RobotContainer.getInstance().m_driveTrain.getPose();
        if(bActive){
           
             //calculate distance and angle to target
        
            calcDistanceToTarget();
            //set rpm based on distance to target
            targetRPM = shotCalc.getRPM(distanceToTarget);
            // once we define turret zones we may have to adujust RPM based on angle to target
            flywheels_LH.setRPM(targetRPM);
            flywheels_RH.setRPM(targetRPM);
            targetAngle = getAngleToTarget();
            turret.setAngle(targetAngle);
        }else{

        }
       
    currentAngle = turret.getCurrAngle();

        switch (status) {
            case READY_TO_FIRE:
                // Handle ready to fire logic
                break;
            case ACQUIRING_TARGETING:
                // Handle targeting logic
                break;
            case IDLE:
                // Handle idle logic
                break;
            case STOPPED:
                // Handle stopped logic
                break;

            default:
                break;
        }

    }  

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    public void setNewTarget(Pose2d target){
        this.targetPose = target;
    }

    public Pose2d getTargetPose(){
        return this.targetPose;
    }

    public String getCombinedStatus(){
        return combinedStatus;
    }

    private void calcDistanceToTarget(){
        distanceToTarget = DriverAssist.getDistanceToTarget(currentPose, targetPose.getTranslation());
    }

    public double getAngleToTarget(){
        return DriverAssist.getAngleToTarget(currentPose, targetPose.getTranslation()).getDegrees();
    }

    public void setStatus(LauncherStatus newStatus){
    
        switch (newStatus) {
        
            case ACQUIRING_TARGETING:
            bActive = true;
                break;
                
            case IDLE:
            bActive = false;
                break;
            case STOPPED:
            bActive = false;
                break;
            default:
            newStatus = LauncherStatus.ACQUIRING_TARGETING;
            bActive = true;
                break;
        }
        this.status = newStatus;
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    // need to create enum for status of launcher READY_TO_FUEL, NOT_READY.
    public enum LauncherStatus {
        READY_TO_FIRE,  
        ACQUIRING_TARGETING,
        IDLE,
        STOPPED;
    }

    //need to create enum for known targets RED_HUB, BLUE_HUB, RED_DEPOT, BLUE_DEPOT, RED_OUTPOST, BLUE_OUTPOST
    // for each enum entry we need to store name, pose2d, "type"
    public enum KnownTargets {
        RED_HUB("Red Hub", new edu.wpi.first.math.geometry.Pose2d(11.907, 4.040, new edu.wpi.first.math.geometry.Rotation2d(0)), "Hub"),
        BLUE_HUB("Blue Hub", new edu.wpi.first.math.geometry.Pose2d(4.623, 4.040, new edu.wpi.first.math.geometry.Rotation2d(0)), "Hub"),
        RED_DEPOT("Red Depot", new edu.wpi.first.math.geometry.Pose2d(15.877, 1.135, new edu.wpi.first.math.geometry.Rotation2d(0)), "Depot"),
        BLUE_DEPOT("Blue Depot", new edu.wpi.first.math.geometry.Pose2d(0.792, 6.967, new edu.wpi.first.math.geometry.Rotation2d(0)), "Depot"),
        RED_OUTPOST("Red Outpost", new edu.wpi.first.math.geometry.Pose2d(15.963, 6.902, new edu.wpi.first.math.geometry.Rotation2d(0)), "Outpost"),
        BLUE_OUTPOST("Blue Outpost", new edu.wpi.first.math.geometry.Pose2d(0.534, 1.135, new edu.wpi.first.math.geometry.Rotation2d(0)), "Outpost");

        // Store name, pose2d, and "type" for each target
        private final String name;
        private final edu.wpi.first.math.geometry.Pose2d pose2d;
        private final String type;

        KnownTargets(String name, edu.wpi.first.math.geometry.Pose2d pose2d, String type) {
            this.name = name;
            this.pose2d = pose2d;
            this.type = type;
        }

        public String getName() {
            return name;
        }

        public edu.wpi.first.math.geometry.Pose2d getPose2d() {
            return pose2d;
        }

        public String getType() {
            return type;
        }
    }
}