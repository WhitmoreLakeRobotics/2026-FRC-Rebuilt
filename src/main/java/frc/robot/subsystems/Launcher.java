// RobotBuilder Version: 6.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.wpilibj.DriverStation.Alliance;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants.CanIds;
import frc.robot.RobotContainer;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Launcher extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    public LFlywheels flywheels_LH;
    public LFlywheels flywheels_RH;
    public LTurret turret;
    private Pose2d targetPose = new Pose2d(1, 4, new Rotation2d(0));
    private LauncherStatus status = LauncherStatus.STOPPED;
    private String combinedStatus = "Initializing";
    private Pose2d currentPose = new Pose2d(1, 4, new Rotation2d(0));
    private double distanceToTarget;
    private double targetAngle;
    private double currentAngle;
    private boolean bActive = false;

    private LinearCalcRef short_shot = new LinearCalcRef(2503, 196, edu.wpi.first.units.Units.Centimeter);
    private LinearCalcRef long_shot = new LinearCalcRef(4407, 379, edu.wpi.first.units.Units.Centimeter);
    private LinearCalc shotCalc = new LinearCalc(short_shot, long_shot);
    private double targetRPM;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    /**
    *
    */
    public Launcher() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

         flywheels_LH = new LFlywheels(CanIds.MOTORS.TOWER1_MOTOR_RIGHT.canId,
                CanIds.MOTORS.TOWER1_MOTOR_LEFT.canId);
         flywheels_RH = new LFlywheels(CanIds.MOTORS.TOWER2_MOTOR_RIGHT.canId,
                CanIds.MOTORS.TOWER2_MOTOR_LEFT.canId);
         turret = new LTurret();
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        if (turret == null || flywheels_LH == null || flywheels_RH == null) {
            combinedStatus = " ...Startin' up... T " + (turret == null) +  " FL " + (flywheels_LH == null) + " FR " + (flywheels_RH == null);
        }else{
            // calculate combined status values from each sub component
        combinedStatus = status.toString() + " T " + turret.getStatus().toString() + " L "
                + flywheels_LH.getStatus().toString() + " R " + flywheels_RH.getStatus().toString();
                currentAngle = turret.getCurrAngle(); 
        
        }
        // update current robot pose from drivetrain odometry
        currentPose = RobotContainer.getInstance().m_driveTrain.getPose();
        if (bActive) {

            // calculate distance and angle to target

            calcDistanceToTarget();
            targetAngle = getAngleToTarget();

            // set rpm based on distance to target
            targetRPM = shotCalc.getRPM(distanceToTarget);
            // insert calcuation for shoot on the fly 
            shootOnTheFly();

            // once we define turret zones we may have to adujust RPM based on angle to target
            
            // set final values to flywheel and turret

            flywheels_LH.setRPM(targetRPM);
            flywheels_RH.setRPM(targetRPM);
            turret.setAngle(targetAngle);
        } else {

        }

        

        switch (status) {
            case READY_TO_FIRE:
                // Handle ready to fire logic
                break;
            case ACQUIRING_TARGETING:
                // Handle targeting logic
                break;
            case IDLE:
                // Handle idle logic
                break;
            case STOPPED:
                // Handle stopped logic
                break;

            default:
                break;
        }

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    public void setNewTarget(Pose2d target) {
        this.targetPose = target;
    }

    public Pose2d getTargetPose() {
        return this.targetPose;
    }

    public String getCombinedStatus() {
        return combinedStatus;
    }

    public LauncherStatus getStatus() {
        return status;
    }


    private void calcDistanceToTarget() {
        distanceToTarget = DriverAssist.getDistanceToTarget(currentPose, targetPose.getTranslation());
    }

    public double getAngleToTarget() {
        return DriverAssist.getAngleToTarget(currentPose, targetPose.getTranslation()).getDegrees();
    }

    public void setStatus(LauncherStatus newStatus) {

        switch (newStatus) {

            case ACQUIRING_TARGETING:
                bActive = true;
                break;

            case IDLE:
                bActive = false;
                break;
            case STOPPED:
                bActive = false;
                break;
            default:
                newStatus = LauncherStatus.ACQUIRING_TARGETING;
                bActive = true;
                break;
        }
        this.status = newStatus;
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    // need to create enum for status of launcher READY_TO_FUEL, NOT_READY.
    public enum LauncherStatus {
        READY_TO_FIRE,
        ACQUIRING_TARGETING,
        IDLE,
        STOPPED;
    }

    private void shootOnTheFly() {
        double vxMPS = RobotContainer.getInstance().m_driveTrain.getSwerveDrive().getRobotVelocity().vxMetersPerSecond;
        double vyMPS = RobotContainer.getInstance().m_driveTrain.getSwerveDrive().getRobotVelocity().vyMetersPerSecond;

        double latency = 0.15; // Tuned constant
        Translation2d futurePos = currentPose.getTranslation().plus(
                new Translation2d(vxMPS, vyMPS).times(latency));

        // 2. GET TARGET VECTOR
        Translation2d goalLocation = targetPose.getTranslation();
        Translation2d targetVec = goalLocation.minus(futurePos);
        double dist = targetVec.getNorm();

        // 3. CALCULATE IDEAL SHOT (Stationary)
        // Note: This returns HORIZONTAL velocity component
        double idealHorizontalSpeed = targetRPM; // Placeholder: Convert RPM to m/s based on your shooter characteristics

        // 4. VECTOR SUBTRACTION
        Translation2d robotVelVec = new Translation2d(vxMPS, vyMPS);
        Translation2d shotVec = targetVec.div(dist).times(idealHorizontalSpeed).minus(robotVelVec);

        // 5. CONVERT TO CONTROLS
        targetAngle = shotVec.getAngle().getDegrees();
        targetRPM = shotVec.getNorm(); // convert back to RPM based on your shooter characteristics

        // 6. SOLVE FOR NEW PITCH/RPM
        // Assuming constant total exit velocity, variable hood:
        // double totalExitVelocity = 15.0; // m/s
        // Clamp to avoid domain errors if we need more speed than possible
        // double ratio = Math.min(targetRPM / totalExitVelocity, 1.0);
        // double newPitch = Math.acos(ratio);

        // 7. SET OUTPUTS
        // turret.setAngle(turretAngle);
        // hood.setAngle(Math.toDegrees(newPitch));
        // shooter.setRPM(calcRPM(totalExitVelocity));

    }

    // need to create enum for known targets RED_HUB, BLUE_HUB, RED_DEPOT,
    // BLUE_DEPOT, RED_OUTPOST, BLUE_OUTPOST
    // for each enum entry we need to store name, pose2d, "type"
    public enum KnownTargets {
        RED_HUB("Red Hub",
                new edu.wpi.first.math.geometry.Pose2d(11.907, 4.040, new edu.wpi.first.math.geometry.Rotation2d(0)),
                "Hub", Alliance.Red),
        BLUE_HUB("Blue Hub",
                new edu.wpi.first.math.geometry.Pose2d(4.623, 4.040, new edu.wpi.first.math.geometry.Rotation2d(0)),
                "Hub", Alliance.Blue),
        RED_DEPOT("Red Depot",
                new edu.wpi.first.math.geometry.Pose2d(15.877, 1.135, new edu.wpi.first.math.geometry.Rotation2d(0)),
                "Depot", Alliance.Red),
        BLUE_DEPOT("Blue Depot",
                new edu.wpi.first.math.geometry.Pose2d(0.792, 6.967, new edu.wpi.first.math.geometry.Rotation2d(0)),
                "Depot", Alliance.Blue),
        RED_OUTPOST("Red Outpost",
                new edu.wpi.first.math.geometry.Pose2d(15.963, 6.902, new edu.wpi.first.math.geometry.Rotation2d(0)),
                "Outpost", Alliance.Red),
        BLUE_OUTPOST("Blue Outpost",
                new edu.wpi.first.math.geometry.Pose2d(0.534, 1.135, new edu.wpi.first.math.geometry.Rotation2d(0)),
                "Outpost", Alliance.Blue),
        BLUE_CENTERTARGET("Blue Center Target",
                new edu.wpi.first.math.geometry.Pose2d(2.706, 1.618, new edu.wpi.first.math.geometry.Rotation2d(0)),
                "Center Target", Alliance.Blue),
        RED_CENTERTARGET("Red Center Target",
                new edu.wpi.first.math.geometry.Pose2d(13.934, 6.219, new edu.wpi.first.math.geometry.Rotation2d(0)),
                "Center Target", Alliance.Red);

        // Store name, pose2d, and "type" for each target
        private final String name;
        private final edu.wpi.first.math.geometry.Pose2d pose2d;
        private final String type;
        private final Alliance alliance;

        KnownTargets(String name, edu.wpi.first.math.geometry.Pose2d pose2d, String type, Alliance alliance) {
            this.name = name;
            this.pose2d = pose2d;
            this.type = type;
            this.alliance = alliance;
        }

        public String getName() {
            return name;
        }

        public edu.wpi.first.math.geometry.Pose2d getPose2d() {
            return pose2d;
        }

        public String getType() {
            return type;
        }
    }
}