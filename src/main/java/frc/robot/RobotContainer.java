// RobotBuilder Version: 6.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: RobotContainer.

package frc.robot;

import frc.robot.Constants.OperatorConstants;
import frc.robot.commands.*;
import frc.robot.commands.Climb.SetStatusClimb;
import frc.robot.commands.DriveTrain.DriveToPos;
import frc.robot.commands.DriveTrain.SetAutoTurn;
import frc.robot.commands.Hopper.SetStatusHopper;
import frc.robot.commands.Intake.SetStatusIntake;
import frc.robot.commands.Launcher.ToggleLaunchTower;
import frc.robot.commands.PMGT.SetPowerProfile;
import frc.robot.commands.Turret.SetTarget;
import frc.robot.commands.Launcher.SpeedChange;
import frc.robot.subsystems.*;
import frc.robot.subsystems.Hopper.HopperStatus;
import frc.robot.subsystems.LTurret.TurretStatus;
import swervelib.SwerveInputStream;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command.InterruptionBehavior;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.button.CommandXboxController;
import edu.wpi.first.wpilibj2.command.button.Trigger;

import java.io.File;

import edu.wpi.first.epilogue.Logged.Importance;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.wpilibj.Filesystem;
import edu.wpi.first.wpilibj.GenericHID;
import edu.wpi.first.wpilibj.XboxController;

import com.fasterxml.jackson.databind.util.Named;
import com.pathplanner.lib.auto.AutoBuilder;
import com.pathplanner.lib.auto.NamedCommands;
import com.pathplanner.lib.commands.PathPlannerAuto;

import frc.robot.subsystems.*;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 * This class is where the bulk of the robot should be declared. Since
 * Command-based is a
 * "declarative" paradigm, very little robot logic should actually be handled in
 * the {@link Robot}
 * periodic methods (other than the scheduler calls). Instead, the structure of
 * the robot
 * (including subsystems, commands, and button mappings) should be declared
 * here.
 */
public class RobotContainer {

  private static RobotContainer m_robotContainer = new RobotContainer();

  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
  // The robot's subsystems
  public final SwerveSubsystem m_driveTrain = new SwerveSubsystem(new File(Filesystem.getDeployDirectory(),
      "swerve"));
  // public final LFlywheels m_flywheels = new LFlywheels(11, 12);
  public final Hopper m_feeder = new Hopper();
  // public final LTurret m_turret = new LTurret();
  public final Launcher m_launcher = new Launcher();
  public final Intake m_intake = new Intake();
  public final Climb m_climb = new Climb();
  public final DriverAssist m_driverAssist = new DriverAssist();
  public final FMSSystem m_fmsSystem = new FMSSystem();
  public final PMGT m_pmgt = new PMGT();
  public double speed_multi = 0.6;

  private boolean bAdrive = false;

  // Joysticks
  private final CommandXboxController articulator_Controller = new CommandXboxController(1);
  private final CommandXboxController driver_Controller = new CommandXboxController(0);

  // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

  // A chooser for autonomous commands
  SendableChooser<Command> autoChooser = new SendableChooser<>();
  SendableChooser<Double> cruiseControl = new SendableChooser();
  SendableChooser<Pose2d> launchPos = new SendableChooser<>();

  /**
   * The container for the robot. Contains subsystems, OI devices, and commands.
   */

  private double getRightXInverted() {
    if (getbAutoDrive()) {
      return m_driveTrain.AutoTurn();
    } else {
      return this.driver_Controller.getRightX() * -1 * speed_multi;
    }
  }

  public void setAutoDrive(boolean bAdrive){
     this.bAdrive = bAdrive; 
  }

  public boolean getbAutoDrive(){
    return bAdrive;
  }

  SwerveInputStream driveAngularVelocity = SwerveInputStream.of(m_driveTrain.getSwerveDrive(),
      () -> driver_Controller.getLeftY() * -1 * speed_multi,
      () -> driver_Controller.getLeftX() * -1 * speed_multi)
      .withControllerRotationAxis(this::getRightXInverted)
      .deadband(OperatorConstants.DEADBAND)
      .scaleTranslation(0.8)
      .allianceRelativeControl(true);

  Command driveFieldOrientedDirectAngle = m_driveTrain.driveFieldOriented(driveAngularVelocity);

  private RobotContainer() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SMARTDASHBOARD
    // Smartdashboard Subsystems
    NamedCommands.registerCommand("Intake", new SetStatusIntake(Intake.STATUS.EXTENDED_INTAKING,m_intake));
    NamedCommands.registerCommand("Climb", new SetStatusClimb(Climb.Status.EXTENDED));
    NamedCommands.registerCommand("Hopper Start", new SetStatusHopper(Hopper.HopperStatus.FUELING));
    NamedCommands.registerCommand("Start Flywheels", new SetTarget(3700, false));
    NamedCommands.registerCommand("All Drive", new SetPowerProfile(PMGT.Profiles.ALLDRIVE));
    NamedCommands.registerCommand("All Launch", new SetPowerProfile(PMGT.Profiles.ALLLAUNCH));
    NamedCommands.registerCommand("Drive While Shooting", new SetPowerProfile(PMGT.Profiles.DRIVE_WHILE_SHOOTING));
    NamedCommands.registerCommand("Drive While Collecting", new SetPowerProfile(PMGT.Profiles.DRIVE_WHILE_COLLECTING));
    //NamedCommands.registerCommand("Climb", new SetPowerProfile(PMGT.Profiles.CLIMB));
    NamedCommands.registerCommand("HStop", new SetStatusHopper(HopperStatus.STOP));
    NamedCommands.registerCommand("FStop", new SetTarget(0.0, false));

    // SmartDashboard Buttons
    SmartDashboard.putData("Autonomous Command", new AutonomousCommand());
    SmartDashboard.putData("Drive", new Drive());

    

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SMARTDASHBOARD
    // Configure the button bindings
    configureButtonBindings();

    // Configure default commands
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SUBSYSTEM_DEFAULT_COMMAND

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SUBSYSTEM_DEFAULT_COMMAND

    // Configure autonomous sendable chooser
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
    cruiseControl.setDefaultOption("60%", 0.6);
    cruiseControl.addOption("80%", 0.8);
    cruiseControl.addOption("70%", 0.7);
    cruiseControl.addOption("40%", 0.4);
    cruiseControl.addOption("30%", 0.3);

    launchPos.setDefaultOption("Red Hub", Launcher.KnownTargets.RED_HUB.getPose2d());
    launchPos.addOption("Blue Hub", Launcher.KnownTargets.BLUE_HUB.getPose2d());
    launchPos.addOption("Red OutPost", Launcher.KnownTargets.RED_OUTPOST.getPose2d());
    launchPos.addOption("Blue OutPost", Launcher.KnownTargets.BLUE_OUTPOST.getPose2d());
    launchPos.addOption("Red Depot", Launcher.KnownTargets.RED_DEPOT.getPose2d());
    launchPos.addOption("Blue Depot", Launcher.KnownTargets.BLUE_DEPOT.getPose2d());
    launchPos.addOption("Red Center", Launcher.KnownTargets.RED_CENTERTARGET.getPose2d());
    launchPos.addOption("Blue Center", Launcher.KnownTargets.BLUE_CENTERTARGET.getPose2d());



    boolean isCompetition = false; // CHANGE AT COMP

    // Build an auto chooser. This will use Commands.none() as the default option.
    // As an example, this will only show autos that start with "comp" while at
    // competition as defined by the programmer
    autoChooser = AutoBuilder.buildAutoChooserWithOptionsModifier(
        (stream) -> isCompetition
            ? stream.filter(auto -> auto.getName().endsWith("COMP"))
            : stream);
    // m_chooser.setDefaultOption("Auto DEFAULT", new
    // PathPlannerAuto("TEST1.auto"));
    // m_chooser.addOption("TEST1", new PathPlannerAuto("TEST1.auto"));

    // autoChooser.setDefaultOption("Start-Climb", new
    // PathPlannerAuto("Start-climb.auto"));
    // autoChooser.addOption("Test Drive Straight", new PathPlannerAuto("Test Drive
    // Straight.auto"));

    SmartDashboard.putData("Auto Mode", autoChooser);


    // autoChooser.setDefaultOption("Start-Climb Test", new PathPlannerAuto("Start-Climb Test.auto"));

    SmartDashboard.putData("Left Turret Toggle", new ToggleLaunchTower(true));
    SmartDashboard.putData("Right Turret Toggle", new ToggleLaunchTower(false));
    SmartDashboard.putData("Start Flywheels", new SetTarget(4000.0, false ));
    SmartDashboard.putData("Stop Flywheels", new SetTarget(0.0, false));
    SmartDashboard.putData("Stop hopper", new SetStatusHopper(HopperStatus.STOP));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

  }

  public static RobotContainer getInstance() {
    return m_robotContainer;
  }

  public void updateDashboard() {
    speed_multi = cruiseControl.getSelected();
    SmartDashboard.putNumber("Current Speed Setting", speed_multi);
    SmartDashboard.putData("Drive Speed Selector", cruiseControl);

    
    String launchTarg = launchPos.getSelected().toString();
    m_launcher.setNewTarget(launchPos.getSelected());
    SmartDashboard.putString("Curr Selected Launch Targ", launchTarg);
    SmartDashboard.putData("Launcher Targets", launchPos);

    if (m_launcher.turret != null) {
      // add turret data to smartdashboard
      SmartDashboard.putNumber("Turret Angle", m_launcher.turret.getCurrAngle());
      SmartDashboard.putNumber("Target Angle", m_launcher.turret.getTargetAngle());
    }
    SmartDashboard.putNumber("Angle To Target", m_launcher.getAngleToTarget());
    SmartDashboard.putNumber("Relative Angle to Target", m_launcher.getRelativeAngleToTarget());
    SmartDashboard.putString("Launcher Status", m_launcher.getCombinedStatus());
    SmartDashboard.putNumber("Tower2LM RPM", m_launcher.flywheels_LH.getLMotorRPM());
    SmartDashboard.putNumber("Tower2RM RPM", m_launcher.flywheels_LH.getRMotorRPM());
    SmartDashboard.putNumber("Tower1LM RPM", m_launcher.flywheels_RH.getLMotorRPM());
    SmartDashboard.putNumber("Tower1RM RPM", m_launcher.flywheels_RH.getRMotorRPM());
    SmartDashboard.putNumber("Target RPM", m_launcher.getTargetRPM());
    SmartDashboard.putNumber("Distance to Target",(DriverAssist.getDistanceToTarget(m_driveTrain.getPose(), m_launcher.getTargetPose().getTranslation()) * 3.28084));

    // add Hopper data to SmartDashboard
    SmartDashboard.putString("Hopper Status", m_feeder.getStatus().toString());

    // add Intake to SmartDashboard
    SmartDashboard.putString("Intake Status", m_intake.getStatus().toString());
    SmartDashboard.putNumber("Intake Position", m_intake.getCurrPos());
    SmartDashboard.putNumber("Intake Target", m_intake.getTargetPos());

    // add Climb to SmartDashboard
    SmartDashboard.putString("Climb Status", m_climb.getStatus().toString());

    // add FMS data to smartdashboard
    SmartDashboard.putString("FMS Status", m_fmsSystem.getStatus().toString());
    SmartDashboard.putString("FMS Data", m_fmsSystem.getPrivateData());
    SmartDashboard.putBoolean("On Shift", m_fmsSystem.getOnShift());
    SmartDashboard.putNumber("Remaining Time", (int) m_fmsSystem.getRemainingTime());
    // add current odometry position to smartdashboard
    SmartDashboard.putNumber("Robot X Position", m_driveTrain.getPose().getX());
    SmartDashboard.putNumber("Robot Y Position", m_driveTrain.getPose().getY());
    SmartDashboard.putNumber("Robot Rotation", m_driveTrain.getPose().getRotation().getDegrees());
    SmartDashboard.putNumber("Drivetrain Velocity X", m_driveTrain.getFieldVelocity().vxMetersPerSecond);
    SmartDashboard.putNumber("Drivetrain Velocity Y", m_driveTrain.getFieldVelocity().vyMetersPerSecond);

    if (m_driveTrain.vision != null) {
      // add vision data to smartdashboard 
      SmartDashboard.putNumber("Curr Pose x", m_driveTrain.vision.LastCalcVisionLocation.getX());
      SmartDashboard.putNumber("Curr Pose y", m_driveTrain.vision.LastCalcVisionLocation.getY());
      SmartDashboard.putNumber("Curr Pose theta",
          m_driveTrain.vision.LastCalcVisionLocation.getRotation().getDegrees());
      SmartDashboard.putNumber("vision latency", m_driveTrain.vision.getVisionTimestamp());
      SmartDashboard.putNumber("Curr Tag ID", m_driveTrain.vision.getLatestID());
    }

    // add driver assist varibles
    SmartDashboard.putString("Drive State", m_driverAssist.getCurrDriveState().toString());
    SmartDashboard.putString("Curr Selected Targets", m_driverAssist.getCurrDriveSelectedTarget().toString());
    SmartDashboard.putString("Curr Selected Target pos",
        m_driverAssist.getCurrDriveSelectedTarget().getTargetPose().toString());
    SmartDashboard.putString("Curr Selected Target Type",
        m_driverAssist.getCurrDriveSelectedTarget().getTargetType().toString());
    SmartDashboard.putString("Curr Tactic", m_driverAssist.getCurrTacticApproach().toString());
    SmartDashboard.putBoolean("At Prev Targ", m_driverAssist.getbAtPrevTarg());
    SmartDashboard.putNumber("Num Of Targets", m_driverAssist.getNumOfTargets());

    SmartDashboard.putBoolean("Left Turret", m_launcher.getbLHF_Enabled());
    SmartDashboard.putBoolean("Right Turret", m_launcher.getbRHF_Enabled());

  }

  /**
   * Use this method to define your button->command mappings. Buttons can be
   * created by
   * instantiating a {@link GenericHID} or one of its subclasses ({@link
   * edu.wpi.first.wpilibj.Joystick} or {@link XboxController}), and then passing
   * it to a
   * {@link edu.wpi.first.wpilibj2.command.button.JoystickButton}.
   */
  private void configureButtonBindings() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS

    m_driveTrain.setDefaultCommand(driveFieldOrientedDirectAngle);

    // Create some buttons

    Trigger rightTrigger = new Trigger(driver_Controller.rightTrigger());

    // drive to pos
    Trigger X_Drive = new Trigger(driver_Controller.x());
    X_Drive
        .onTrue(new DriveToPos(DriverAssist.Targets.RRIGHTCLIMB.getTargetPose(), m_driveTrain)
            .until(this::driverIsMoving));

    Trigger A_Drive = new Trigger(driver_Controller.a());
    A_Drive.onTrue(new SetTarget(3700.0, false));

    Trigger B_Drive = new Trigger(driver_Controller.b());
    B_Drive.onTrue(new SetTarget(0.0, false));


    Trigger Y_Trigger = new Trigger(driver_Controller.y());
    Y_Trigger.onTrue( new SetAutoTurn(true));

    // dump hopper
    Trigger leftTrigger = new Trigger(driver_Controller.leftTrigger());
    leftTrigger.onTrue(new SetStatusHopper(HopperStatus.REVERSAL))
        .onFalse(new SetStatusHopper(HopperStatus.INDEXING));

    // right bumper
    Trigger rightBumper = new Trigger(driver_Controller.rightBumper());
    rightBumper.onTrue(new SetTarget(3000, true));

    // toggle intake
    rightTrigger.onTrue(new SetStatusIntake(Intake.STATUS.EXTENDED_INTAKING, true));

    // climb up
    Trigger dpad_up = new Trigger(driver_Controller.povUp());
    dpad_up.onTrue(new SetStatusClimb(Climb.Status.DEPLOYEDL1));

    // climb down
    Trigger dpad_down = new Trigger(driver_Controller.povDown());
    dpad_down.onTrue(new SetStatusClimb(Climb.Status.L1));

    // toggle launch
    Trigger rightJoyStick = new Trigger(driver_Controller.rightStick());
    rightJoyStick.onTrue(new SetStatusHopper(HopperStatus.FUELING, true));

    // sotf speed
    Trigger leftJoyStick = new Trigger(driver_Controller.leftStick());
    // leftJoyStick =.onTrue(new)

    // intake full in
    Trigger Back_Button = new Trigger(driver_Controller.back());
    Back_Button.onTrue(new SetStatusIntake(Intake.STATUS.RETRACTED));

    Trigger aRight_Bumper = new Trigger(articulator_Controller.rightBumper());
    aRight_Bumper.onTrue(new SetStatusIntake(Intake.STATUS.RETRACTED));

    Trigger aLeft_Bumper = new Trigger(articulator_Controller.leftBumper());
    aLeft_Bumper.onTrue(new SetStatusIntake(Intake.STATUS.EXTENDED_INTAKING));

    Trigger aDpad_Up = new Trigger(articulator_Controller.povUp());
    aDpad_Up.onTrue(new SpeedChange(true));

    Trigger aDpad_Down = new Trigger(articulator_Controller.povDown());
    aDpad_Down.onTrue(new SpeedChange(false));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS
  }

  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS
  public CommandXboxController getDriver_Controller() {
    return driver_Controller;
  }

  public CommandXboxController getArticulator_Controller() {
    return articulator_Controller;
  }

  public boolean driverIsMoving() {
    // System.out.println("Driver is moving: " +
    // drive_Controller.getLeftY() + " " + drive_Controller.getLeftX() + " " +
    // drive_Controller.getRightX() + " " + drive_Controller.y().getAsBoolean());
    // System.out.println("HID verison " + drive_Controller.getHID().getLeftY()
    // + " " + drive_Controller.getHID().getLeftX() + " " +
    // drive_Controller.getHID().getRightX());
    // ((Math.abs(drive_Controller.getLeftY()) > 0.1 )||
    // (Math.abs(drive_Controller.getLeftX()) > 0.1)
    // ||( Math.abs(drive_Controller.getRightX()) > 0.1) ||
    // drive_Controller.y().getAsBoolean()));
    return Math.abs(driver_Controller.getLeftY()) > 0.1 || Math.abs(driver_Controller.getLeftX()) > 0.1
        || Math.abs(driver_Controller.getRightX()) > 0.1;
    // return drive_Controller.y().getAsBoolean();
  }

  // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS

  /**
   * Use this to pass the autonomous command to the main {@link Robot} class.
   *
   * @return the command to run in autonomous
   */
  public Command getAutonomousCommand() {
    // The selected command will be run in autonomous
    return autoChooser.getSelected();
  }

}
