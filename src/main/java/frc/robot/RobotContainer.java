// RobotBuilder Version: 6.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: RobotContainer.

package frc.robot;

import frc.robot.commands.*;
import frc.robot.commands.DriveTrain.DriveToPos;
import frc.robot.commands.Hopper.SetStatusHopper;
import frc.robot.commands.Intake.SetStatusIntake;
import frc.robot.subsystems.*;
import frc.robot.subsystems.Hopper.HopperStatus;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command.InterruptionBehavior;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.button.CommandXboxController;
import edu.wpi.first.wpilibj2.command.button.Trigger;

import java.io.File;

import edu.wpi.first.wpilibj.Filesystem;
import edu.wpi.first.wpilibj.GenericHID;
import edu.wpi.first.wpilibj.XboxController;
import com.pathplanner.lib.auto.AutoBuilder;
import frc.robot.subsystems.*;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 * This class is where the bulk of the robot should be declared.  Since Command-based is a
 * "declarative" paradigm, very little robot logic should actually be handled in the {@link Robot}
 * periodic methods (other than the scheduler calls).  Instead, the structure of the robot
 * (including subsystems, commands, and button mappings) should be declared here.
 */
public class RobotContainer {

  private static RobotContainer m_robotContainer = new RobotContainer();

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // The robot's subsystems
    public final SwerveSubsystem m_driveTrain = new SwerveSubsystem(new File(Filesystem.getDeployDirectory(),
                                                                                "swerve"));
    //public final LFlywheels m_flywheels = new LFlywheels(11, 12);
    public final Hopper m_feeder = new Hopper();
   // public final LTurret m_turret = new LTurret();
    public final Launcher m_launcher = new Launcher();
    public final Intake m_intake = new Intake();
    public final Climb m_climb = new Climb();
    public final DriverAssist m_driverAssist = new DriverAssist();
    public final FMSSystem m_fmsSystem = new FMSSystem();
    public final PMGT m_pmgt = new PMGT();

// Joysticks
  private final CommandXboxController articulator_Controller = new CommandXboxController(1);
  private final CommandXboxController driver_Controller = new CommandXboxController(0);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

  
  // A chooser for autonomous commands
  SendableChooser<Command> autoChooser = new SendableChooser<>();

  /**
  * The container for the robot.  Contains subsystems, OI devices, and commands.
  */
  private RobotContainer() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SMARTDASHBOARD
    // Smartdashboard Subsystems
    


    // SmartDashboard Buttons
    SmartDashboard.putData("Autonomous Command", new AutonomousCommand());
    SmartDashboard.putData("Drive", new Drive());

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SMARTDASHBOARD
    // Configure the button bindings
    configureButtonBindings();

    // Configure default commands
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SUBSYSTEM_DEFAULT_COMMAND


        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SUBSYSTEM_DEFAULT_COMMAND

    // Configure autonomous sendable chooser
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
        boolean isCompetition = false; // CHANGE AT COMP

    // Build an auto chooser. This will use Commands.none() as the default option.
    // As an example, this will only show autos that start with "comp" while at
    // competition as defined by the programmer
    autoChooser = AutoBuilder.buildAutoChooserWithOptionsModifier(
        (stream) -> isCompetition
            ? stream.filter(auto -> auto.getName().endsWith("COMP"))
            : stream);
    // m_chooser.setDefaultOption("Auto DEFAULT", new
    // PathPlannerAuto("TEST1.auto"));
    // m_chooser.addOption("TEST1", new PathPlannerAuto("TEST1.auto"));

    // autoChooser.setDefaultOption("Start-Climb", new
    // PathPlannerAuto("Start-climb.auto"));
    // autoChooser.addOption("Test Drive Straight", new PathPlannerAuto("Test Drive
    // Straight.auto"));
    

    SmartDashboard.putData("Auto Mode", autoChooser);

    autoChooser.setDefaultOption("Autonomous Command", new AutonomousCommand());

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

  }

  public static RobotContainer getInstance() {
    return m_robotContainer;
  }
public void updateDashboard() {

    //add turret data to smartdashboard
    SmartDashboard.putNumber("Turret Angle", m_launcher.turret.getCurrAngle());
    SmartDashboard.putNumber("Target Angle", m_launcher.turret.getTargetAngle());
    SmartDashboard.putNumber("Angle To Target", m_launcher.getAngleToTarget());
    SmartDashboard.putString("Launcher Status", m_launcher.getCombinedStatus());

    //add FMS data to smartdashboard
    SmartDashboard.putString("FMS Status", m_fmsSystem.getStatus().toString());
    SmartDashboard.putString("FMS Data", m_fmsSystem.getPrivateData());
    SmartDashboard.putNumber("Remaining Time", (int) m_fmsSystem.getRemainingTime());
   //add current odometry position to smartdashboard
  SmartDashboard.putNumber("Robot X Position", m_driveTrain.getPose().getX());
  SmartDashboard.putNumber("Robot Y Position", m_driveTrain.getPose().getY());
  SmartDashboard.putNumber("Robot Rotation", m_driveTrain.getPose().getRotation().getDegrees());
  SmartDashboard.putNumber("Drivetrain Velocity X", m_driveTrain.getFieldVelocity().vxMetersPerSecond);
  SmartDashboard.putNumber("Drivetrain Velocity Y", m_driveTrain.getFieldVelocity().vyMetersPerSecond);

   //add vision data to smartdashboard
   SmartDashboard.putNumber("Curr Pose x", m_driveTrain.vision.LastCalcVisionLocation.getX());
   SmartDashboard.putNumber("Curr Pose y", m_driveTrain.vision.LastCalcVisionLocation.getY());
   SmartDashboard.putNumber("Curr Pose theta", m_driveTrain.vision.LastCalcVisionLocation.getRotation().getDegrees()); 
   SmartDashboard.putNumber("vision latency",m_driveTrain.vision.getVisionTimestamp());
   SmartDashboard.putNumber("Curr Tag ID", m_driveTrain.vision.getLatestID());
   //add driver assist varibles.
   SmartDashboard.putString("Drive State", m_driverAssist.getCurrDriveState().toString());
   SmartDashboard.putString("Curr Selected Targets", m_driverAssist.getCurrDriveSelectedTarget().toString());
   SmartDashboard.putString("Curr Selected Target pos", m_driverAssist.getCurrDriveSelectedTarget().getTargetPose().toString());
   SmartDashboard.putString("Curr Selected Target Type", m_driverAssist.getCurrDriveSelectedTarget().getTargetType().toString());
   SmartDashboard.putString("Curr Tactic", m_driverAssist.getCurrTacticApproach().toString());
   SmartDashboard.putBoolean("At Prev Targ", m_driverAssist.getbAtPrevTarg());
   SmartDashboard.putNumber("Num Of Targets", m_driverAssist.getNumOfTargets());

  }
  /**
   * Use this method to define your button->command mappings.  Buttons can be created by
   * instantiating a {@link GenericHID} or one of its subclasses ({@link
   * edu.wpi.first.wpilibj.Joystick} or {@link XboxController}), and then passing it to a
   * {@link edu.wpi.first.wpilibj2.command.button.JoystickButton}.
   */
  private void configureButtonBindings() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS
// Create some buttons
Trigger X_Drive = new Trigger(driver_Controller.x());
    X_Drive
        .onTrue(new DriveToPos(DriverAssist.Targets.RRIGHTCLIMB.getTargetPose(), m_driveTrain)
            .until(this::driverIsMoving));
    Trigger leftTrigger = new Trigger(driver_Controller.leftTrigger());
    leftTrigger.onTrue (new SetStatusHopper(HopperStatus.REVERSAL))
    .onFalse(new SetStatusHopper(HopperStatus.INDEXING));
    // dump hopper
    Trigger rightTrigger = new Trigger(driver_Controller.rightTrigger());
    // toggle intake
        rightTrigger.onTrue(new SetStatusIntake(Intake.STATUS.HALF_EXTENDED, true));
    Trigger dpad_up = new Trigger(driver_Controller.povUp());
    // climb up
    Trigger dpad_down = new Trigger(driver_Controller.povDown());
    // climb down
    Trigger rightJoyStick = new Trigger(driver_Controller.rightStick());
    // toggle launch
    Trigger leftJoyStick = new Trigger(driver_Controller.leftStick());
    // sotf speed
    Trigger Back_Button = new Trigger(driver_Controller.back());
    Back_Button.onTrue (new SetStatusIntake(Intake.STATUS.RETRACTED));
    // intake full in

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS
  }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS
public CommandXboxController getDriver_Controller() {
      return driver_Controller;
    }

public CommandXboxController getArticulator_Controller() {
      return articulator_Controller;
    }
 public boolean driverIsMoving() {
   // System.out.println("Driver is moving: " +
    //  drive_Controller.getLeftY() + " " + drive_Controller.getLeftX() + " " + 
    //  drive_Controller.getRightX() + " " + drive_Controller.y().getAsBoolean());
     // System.out.println("HID verison " + drive_Controller.getHID().getLeftY() 
     // + " " + drive_Controller.getHID().getLeftX() + " " + drive_Controller.getHID().getRightX());
       // ((Math.abs(drive_Controller.getLeftY()) > 0.1 )|| (Math.abs(drive_Controller.getLeftX()) > 0.1)
          //  ||( Math.abs(drive_Controller.getRightX()) > 0.1) || 
           // drive_Controller.y().getAsBoolean()));
    return Math.abs(driver_Controller.getLeftY()) > 0.1 || Math.abs(driver_Controller.getLeftX()) > 0.1
        || Math.abs(driver_Controller.getRightX()) > 0.1;
     //return drive_Controller.y().getAsBoolean();
  }


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS

  /**
   * Use this to pass the autonomous command to the main {@link Robot} class.
   *
   * @return the command to run in autonomous
  */
  public Command getAutonomousCommand() {
    // The selected command will be run in autonomous
    return autoChooser.getSelected();
  }
  

}

